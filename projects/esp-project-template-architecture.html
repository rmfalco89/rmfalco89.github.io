<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32 Project Template - Riccardo Marino</title>
    <link rel="stylesheet" href="../css/project.css">
</head>
<body>
    <nav class="back-nav">
        <a href="../index.html" class="back-link">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="15 18 9 12 15 6"></polyline>
            </svg>
            Back to Portfolio
        </a>
    </nav>
    
    <article class="project-detail">
        <header class="project-header">
            <h1>ESP32 Project Template</h1>
            <p class="subtitle">Production-Ready IoT Foundation</p>
            <div class="project-meta">
                <a href="https://github.com/rmfalco89/esp-project-template" target="_blank" class="github-link">
                    View on GitHub
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
                        <polyline points="15 3 21 3 21 9"></polyline>
                        <line x1="10" y1="14" x2="21" y2="3"></line>
                    </svg>
                </a>
                <div class="tech-stack">
                    <span class="tech-tag">C++</span>
                    <span class="tech-tag">Arduino</span>
                    <span class="tech-tag">PlatformIO</span>
                    <span class="tech-tag">AsyncWebServer</span>
                </div>
            </div>
        </header>
        
        <section class="content-section">
            <h2>Overview</h2>
            <p>This project is a production-ready template for ESP32 and ESP8266 IoT devices that solves one of embedded development's biggest challenges: <strong>starting from a solid foundation rather than reinventing the wheel</strong>. It provides 95% code sharing between ESP32 and ESP8266 platforms, complete with WiFi management, web-based configuration, OTA updates, EEPROM persistence, and comprehensive monitoring.</p>
            <p>Instead of writing boilerplate WiFi connection logic, configuration storage, and update mechanisms for every new IoT project, developers can clone this template and immediately start implementing their sensor logic, actuator control, or custom features.</p>
        </section>
        
        <section class="content-section">
            <h2>The Problem: Embedded Development Friction</h2>
            <p>Every embedded IoT project needs the same foundational components:</p>
            <ul>
                <li>WiFi connection management with fallback to AP mode</li>
                <li>Persistent configuration storage</li>
                <li>Web interface for device setup</li>
                <li>Over-the-air (OTA) firmware updates</li>
                <li>Logging and debugging infrastructure</li>
                <li>Reset/boot loop protection</li>
                <li>Memory monitoring</li>
            </ul>
            <p>Without a template, developers spend days or weeks implementing these basics before writing a single line of domain-specific code. Worse, most implementations lack production-ready features like boot loop protection, rollback safety, or proper error handling.</p>
        </section>
        
        <section class="content-section">
            <h2>Architecture: Dual-Platform Code Sharing</h2>
            
            <div class="architecture-diagram">
                <pre>
esp-project-template/
├── src/
│   ├── main.cpp                    # Project entry point
│   ├── globals.h/cpp               # Project-specific globals
│   ├── serverHandles.cpp/h         # Project-specific HTTP routes
│   ├── system_config.cpp/h         # Project EEPROM configuration
│   └── common/                     # ⭐ Shared platform-agnostic code
│       ├── common_main.cpp/h       # Core setup and loop
│       ├── wifi_handler.cpp/h      # WiFi management
│       ├── server_handler.cpp/h    # Web server
│       ├── server_handles.cpp      # Built-in routes
│       ├── ota_handler.cpp/h       # GitHub-based OTA updates
│       ├── device_configuration.h  # Configuration structs
│       ├── eeprom_utils.tpp        # EEPROM utilities
│       ├── memory_stats.cpp/h      # RAM monitoring
│       └── version.h               # Auto-incremented version
└── platformio.ini                  # Build configuration
                </pre>
            </div>
            
            <p>The <code>src/common/</code> folder contains all platform-agnostic code. Platform-specific differences (ESP32 vs ESP8266) are handled with compiler guards, meaning <strong>95% of the code is shared</strong> between platforms.</p>
        </section>
        
        <section class="content-section">
            <h2>Key Features</h2>
            
            <div class="feature-card">
                <h3>WiFi Management: Smart Configuration Mode</h3>
                <ul>
                    <li><strong>Zero-Touch Configuration:</strong> On first boot, device starts AP mode broadcasting <code>ArduinoNet</code></li>
                    <li><strong>Smart Features:</strong> Quick restart detection, boot loop protection, mDNS discovery</li>
                    <li><strong>WiFi Health Monitoring:</strong> Active health checks every 60 seconds (pings google.com)</li>
                    <li><strong>Platform-Specific Tuning:</strong> Disabled sleep mode for improved stability</li>
                </ul>
            </div>
            
            <div class="feature-card">
                <h3>Configuration Management: Type-Safe EEPROM</h3>
                <ul>
                    <li><strong>Template-Based EEPROM Utilities:</strong> Generic, type-safe EEPROM functions via C++ templates</li>
                    <li><strong>Checksum Validation:</strong> Prevents corruption with CRC checks</li>
                    <li><strong>Struct Packing:</strong> <code>#pragma pack(push, 1)</code> prevents alignment issues</li>
                    <li><strong>Address Management:</strong> Smart calculation pattern prevents memory overlaps</li>
                </ul>
            </div>
            
            <div class="feature-card">
                <h3>Over-The-Air (OTA) Updates</h3>
                <ul>
                    <li><strong>GitHub Releases Integration:</strong> Uses GitHub as distribution mechanism</li>
                    <li><strong>Version Comparison:</strong> Semantic versioning prevents unnecessary updates</li>
                    <li><strong>Browser-Based Manual Upload:</strong> Fallback mechanism for GitHub failures</li>
                    <li><strong>Watchdog Integration:</strong> Feeds watchdog during large downloads</li>
                </ul>
            </div>
            
            <div class="feature-card">
                <h3>Web Server: Async & Non-Blocking</h3>
                <ul>
                    <li><strong>ESPAsyncWebServer:</strong> Handles multiple clients simultaneously without blocking</li>
                    <li><strong>Built-In Routes:</strong> Home, config, reboot, OTA, logs stream</li>
                    <li><strong>WebSocket Logging:</strong> Real-time log viewer accessible via browser</li>
                    <li><strong>Custom Routes:</strong> Easy to add project-specific endpoints</li>
                </ul>
            </div>
            
            <div class="feature-card">
                <h3>Monitoring & Diagnostics</h3>
                <ul>
                    <li><strong>Memory Statistics:</strong> 24-hour tracking with min/max/avg</li>
                    <li><strong>Power Monitoring:</strong> ESP8266 can measure its own supply voltage</li>
                    <li><strong>Reset Cause Detection:</strong> Logs why the device rebooted</li>
                    <li><strong>Dual Logging:</strong> Serial + WebSocket for flexible debugging</li>
                </ul>
            </div>
        </section>
        
        <section class="content-section">
            <h2>Main Loop Architecture</h2>
            <p>The template uses a <strong>status code pattern</strong> to control execution flow:</p>
            <div class="code-block">
                <pre>
void loop() {
    int status = commonLoop();
    
    if (status == 2) {  // Boot loop protection
        delay(500);
        return;
    }
    
    if (status == 1) {  // Configuration mode
        delay(500);
        return;
    }
    
    // status == 0: Normal operation
    // Your project code runs here
    readSensors();
    updateActuators();
}
                </pre>
            </div>
            <p><code>commonLoop()</code> handles all housekeeping: WiFi health checks, LED heartbeat, watchdog feeding, OTA update checks, and quick restart counter reset.</p>
        </section>
        
        <section class="content-section">
            <h2>Developer Experience</h2>
            <ul class="highlights-list">
                <li><strong>Auto-Incrementing Version Numbers:</strong> <code>extra_script_pre.py</code> bumps version on every build</li>
                <li><strong>Serial Monitor Auto-Open:</strong> <code>extra_script_post.py</code> opens monitor after upload</li>
                <li><strong>Dual-Environment Setup:</strong> Build ESP32 or ESP8266 with single command</li>
                <li><strong>Poetry/PlatformIO Integration:</strong> Clean dependency management</li>
            </ul>
        </section>
        
        <section class="content-section">
            <h2>Extending the Template</h2>
            <p><strong>Adding a Custom Sensor:</strong></p>
            <ol>
                <li>Create sensor handler (<code>src/dht_handler.cpp</code>)</li>
                <li>Add HTTP route (<code>src/serverHandles.cpp</code>)</li>
                <li>Update main.cpp to call setup and add routes</li>
            </ol>
            <p><strong>Adding Custom Configuration:</strong></p>
            <ol>
                <li>Define struct in <code>src/system_config.h</code></li>
                <li>Calculate address in <code>src/main.cpp</code></li>
                <li>Implement save/load in <code>src/system_config.cpp</code></li>
            </ol>
        </section>
        
        <section class="content-section">
            <h2>Production Deployment</h2>
            <h3>Reliability Features Already Implemented</h3>
            <ul class="highlights-list">
                <li><strong>Boot loop protection</strong> — Prevents infinite crash loops</li>
                <li><strong>Watchdog timer</strong> — Reboots on hangs (30s ESP32, 8s ESP8266)</li>
                <li><strong>WiFi health checks</strong> — Detects "connected but broken" states</li>
                <li><strong>Configuration validation</strong> — Tests WiFi before saving</li>
                <li><strong>Quick restart detection</strong> — Easy entry into config mode</li>
                <li><strong>Memory tracking</strong> — 24-hour stats for leak detection</li>
                <li><strong>Reset cause logging</strong> — Diagnose field failures</li>
            </ul>
        </section>
        
        <section class="content-section">
            <h2>Performance Characteristics</h2>
            <p><strong>ESP32 (240MHz, ~320KB RAM):</strong></p>
            <ul>
                <li>Boot time: ~3-5 seconds</li>
                <li>WiFi connection: ~2-5 seconds</li>
                <li>Memory usage: ~60KB (leaves 260KB for application)</li>
                <li>Power consumption: ~160mA active</li>
            </ul>
            <p><strong>ESP8266 (80MHz, ~80KB RAM):</strong></p>
            <ul>
                <li>Boot time: ~5-8 seconds</li>
                <li>WiFi connection: ~3-7 seconds</li>
                <li>Memory usage: ~40KB (leaves 40KB for application)</li>
                <li>Power consumption: ~80mA active</li>
            </ul>
        </section>
        
        <section class="content-section">
            <h2>Why This Template Matters</h2>
            <ul class="highlights-list">
                <li><strong>For Hobbyists:</strong> Stop reinventing WiFi connection code. Clone this, add your sensor logic, and you're done.</li>
                <li><strong>For Prototypes:</strong> Ship a working demo in hours instead of days. The web interface impresses clients.</li>
                <li><strong>For Production:</strong> Boot loop protection, watchdog timers, health checks, and OTA updates are already battle-tested.</li>
                <li><strong>For Multi-Platform Projects:</strong> Write your logic once, deploy to ESP32 (for performance) or ESP8266 (for cost) without code changes.</li>
            </ul>
        </section>
    </article>
</body>
</html>
