<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SmarterHome Webserver | Riccardo Marino</title>
    <link rel="stylesheet" href="../css/style.css">
</head>
<body>
    <div class="container">
        <article>
            <a href="../index.html" class="back-link">← Back to Portfolio</a>
            <h1>SmarterHome Webserver: Advanced Home Automation Orchestration</h1>
<strong>Repository:</strong> <a href="https://github.com/rmfalco89/smarterHome-webserver" target="_blank">rmfalco89/smarterHome-webserver</a>
<strong>Stack:</strong> Django 5.0, Django REST Framework, WebSocket, Plotly, SQLite
<strong>Integration:</strong> Homebridge, Home Assistant, Arduino IoT Devices
<p>---</p>
<h2>Overview</h2>
<p>SmarterHome Webserver is a sophisticated Django-based orchestration layer that sits between IoT sensor devices and home automation platforms (Homebridge and Home Assistant). It provides centralized monitoring, control logic, and data analytics for custom smart home devices—with a particularly interesting application: automated mushroom cultivation.</p>
<p>This is the webserver component of a three-part system that extends the capabilities of existing home automation platforms with custom device control, threshold-based automation, firmware management, and detailed historical analytics.</p>
<p>---</p>
<h2>Architecture</h2>
<h3>System Components</h3>
<p>The project consists of two main Django applications:</p>
<p>1. <strong><code>homebridgecomm</code></strong> - General-purpose IoT device management and home automation bridge</p>
<p>2. <strong><code>shrooms</code></strong> - Specialized mushroom growing chamber automation (growing and fruiting stages)</p>
<p>Both apps share similar patterns but serve different purposes:</p>
<ul>
<li><strong>homebridgecomm</strong> integrates with Homebridge (Apple HomeKit) and Home Assistant</li>
<li><strong>shrooms</strong> focuses on mushroom cultivation automation with specialized parameters like FAE (Fresh Air Exchange) intervals</li>
</ul>
<h3>Key Integration Points</h3>
<pre><code>┌─────────────┐
<p>│   Arduino   │ ──HTTP POST──> ┌──────────────────┐</p>
<p>│   Devices   │ <──Firmware──── │  Django Server   │</p>
<p>└─────────────┘                 │                  │</p>
<p>│  ┌────────────┐  │</p>
<p>│  │ Device     │  │</p>
<p>│  │ Control    │  │</p>
<p>┌─────────────┐                 │  └─────┬──────┘  │</p>
<p>│ Homebridge  │ <──REST API───> │        │         │</p>
<p>│   Server    │                 │  ┌─────▼──────┐  │</p>
<p>└─────────────┘                 │  │ Homebridge │  │</p>
<p>│  │ Control    │  │</p>
<p>┌─────────────┐                 │  └────────────┘  │</p>
<p>│    Home     │ <──WebSocket──> │                  │</p>
<p>│  Assistant  │                 │  ┌────────────┐  │</p>
<p>└─────────────┘                 │  │ HomeAssist │  │</p>
<p>│  │ Control    │  │</p>
<p>│  └────────────┘  │</p>
<p>└──────────────────┘</code></pre></p>
<p>---</p>
<h2>Core Implementation Details</h2>
<h3>1. Smart Data Persistence with Delta Compression</h3>
<p>One of the most elegant optimizations is the delta-based data storage for sensor readings:</p>
<pre><code>def register_device_reading(name: str, data: dict) -> str:
<p># Check latest device_reading</p>
<p>reading_obj = LAST_READING_BY_DEVICE.get(device_name(name))</p>
<p>need_to_add = False</p>
<p>if reading_obj:</p>
<p>for k, v in data.items():</p>
<p>if k == "temp":</p>
<p>acceptable_gap = config["temp_threshold_gap"]</p>
<p>elif k == "rh":</p>
<p>acceptable_gap = config["rh_threshold_gap"]</p>
<p>if not gap_is_acceptable(v, last_reading[k], acceptable_gap):</p>
<p>need_to_add = True</p>
<p>if need_to_add:</p>
<p>reading_obj = DeviceReading(device=device, data=data, counter=0)</p>
<p>reading_obj.counter += 1</p>
<p>reading_obj.save()</code></pre></p>
<strong>Why This Matters:</strong>
<ul>
<li>Sensors report every ~2 minutes, but temp/humidity change slowly</li>
<li>Instead of creating a new DB row for 75.1°F → 75.2°F, increment the counter</li>
<li>When visualizing, expand the counter: one row with counter=30 represents ~1 hour of stable readings</li>
<li>Dramatically reduces database size while maintaining full historical accuracy</li>
</ul>
<h3>2. Threshold-Based Automation with Hysteresis</h3>
<p>The system implements intelligent threshold control to prevent rapid on/off cycling:</p>
<pre><code>def act_on_reading(device, config, reading) -> str:
<p>if data["temp"] > config["heater_temp_threshold"] + config["temp_threshold_gap"]:</p>
<p>switch_on = False  # Too hot, turn off</p>
<p>elif data["temp"] < config["heater_temp_threshold"] - config["temp_threshold_gap"]:</p>
<p>switch_on = True   # Too cold, turn on</p>
<p>else:</p>
<p>pass  # Within acceptable range, no action</code></pre></p>
<strong>Example:</strong> Target temp = 75°F, gap = 2°F
<ul>
<li>Heater turns <strong>ON</strong> when temp < 73°F</li>
<li>Heater turns <strong>OFF</strong> when temp > 77°F</li>
<li>Between 73-77°F: maintain current state</li>
</ul>
<p>This prevents the "chattering" problem where a device rapidly toggles around a single threshold.</p>
<h3>3. Multi-Platform Integration</h3>
<h4>Homebridge (HTTP REST API)</h4>
<pre><code>class HomeBridgeServer:
<p>def turn_switch(self, accessory_name: str, on: bool) -> bool:</p>
<p>url = f"{self.base_url}/api/accessories/{accessory_id}"</p>
<p>payload = {"characteristicType": "On", "value": on}</p>
<p>response = requests.put(url, headers=auth_headers, json=payload)</p>
<p>return response.status_code == 200</code></pre></p>
<ul>
<li>Authenticates with Homebridge UI</li>
<li>Token refresh with expiration checking</li>
<li>Caches accessory list (refresh interval configurable: 2 min dev, 8 hours prod)</li>
</ul>
<h4>Home Assistant (WebSocket)</h4>
<pre><code>class HomeAssistantControl:
<p>def update_virtual_sensor(self, sensor_name: str, value: float):</p>
<p>message = {</p>
<p>"id": self.message_id,</p>
<p>"type": "call_service",</p>
<p>"domain": "input_number",</p>
<p>"service": "set_value",</p>
<p>"service_data": {</p>
<p>"entity_id": f"input_number.{sensor_name}",</p>
<p>"value": value</p>
<p>}</p>
<p>}</p>
<p>self.ws.send(json.dumps(message))</code></pre></p>
<ul>
<li>WebSocket connection with reconnection logic</li>
<li>Long-lived access tokens</li>
<li>Updates virtual sensors in real-time for custom devices not natively supported</li>
</ul>
<h3>4. Over-The-Air (OTA) Firmware Updates</h3>
<p>Devices can self-update when new firmware is available:</p>
<pre><code>@csrf_exempt
<p>def upgrade_firmware(request: HttpRequest, device: str):</p>
<p>data = request.GET.dict()</p>
<p>newer_firmware = firmware_control.get_path_to_newer_firmware_if_found(</p>
<p>device, data['sw_version'], data['binary_name']</p>
<p>)</p>
<p>if not newer_firmware:</p>
<p>return HttpResponse(status=204)  # No update available</p>
<p>with open(newer_firmware, 'rb') as f:</p>
<p>response = HttpResponse(f.read(), content_type='application/octet-stream')</p>
<p>response['Content-Disposition'] = f'attachment; filename="{os.path.basename(newer_firmware)}"'</p>
<p>return response</code></pre></p>
<strong>Workflow:</strong>
<p>1. Device POSTs its current version on startup</p>
<p>2. Server checks GitHub releases for newer firmware</p>
<p>3. If available, device downloads and flashes new version</p>
<p>4. Device reboots with updated firmware</p>
<h3>5. Mushroom Growing Automation</h3>
<p>The <code>shrooms</code> app is specifically designed for automated mushroom cultivation:</p>
<pre><code>class GrowingSession(models.Model):
<p>chamber_type = models.IntegerField(choices=[</p>
<p>(0, 'Growing Chamber'),</p>
<p>(1, 'Fruiting Chamber'),</p>
<p>])</p>
<p># Temperature and humidity control</p>
<p>target_temp_f = models.DecimalField(max_digits=5, decimal_places=1)</p>
<p>temp_gap_f = models.DecimalField(max_digits=3, decimal_places=1)</p>
<p>target_humidity = models.DecimalField(max_digits=5, decimal_places=2)</p>
<p>humidity_gap = models.DecimalField(max_digits=3, decimal_places=1)</p>
<p># Fresh Air Exchange (FAE) automation</p>
<p>fae_interval_seconds = models.PositiveIntegerField()</p>
<p>fae_duration_seconds = models.PositiveIntegerField()</p>
<p>fae_interval_short_push_seconds = models.PositiveIntegerField()</p>
<p>fae_duration_short_push_seconds = models.PositiveIntegerField()</code></pre></p>
<strong>Why It's Interesting:</strong>
<ul>
<li>Mushrooms require precise environmental control</li>
<li>Growing stage: higher humidity (95%+), lower temp, minimal FAE</li>
<li>Fruiting stage: lower humidity (85-90%), higher temp, frequent FAE</li>
<li>Automated transitions between stages based on schedule</li>
<li>Fine-grained FAE control: long intervals with occasional short "push" cycles</li>
</ul>
<h3>6. Data Visualization with Plotly</h3>
<p>Real-time and historical monitoring dashboard:</p>
<pre><code>def display_readings(request):
<p>readings = DeviceReading.objects.filter(</p>
<p>device=device_id,</p>
<p>timestamp__date__range=[start_date, end_date]</p>
<p>).order_by('timestamp')</p>
<p>temp_x, temp_y, rh_x, rh_y = [], [], [], []</p>
<p>for value in readings:</p>
<p># Expand counter for visualization</p>
<p>for i in range(value.counter):</p>
<p>timestamp = value.timestamp + timedelta(seconds=i * 130)</p>
<p>temp_x.append(timestamp)</p>
<p>temp_y.append(value.data['temp'])</p>
<p>rh_x.append(timestamp)</p>
<p>rh_y.append(value.data['rh'])</p>
<p># Add device restart markers</p>
<p>for restart in restarts:</p>
<p>annotation = Annotation(</p>
<p>x=restart.timestamp, y=0,</p>
<p>showarrow=True, arrowhead=1, ay=-20</p>
<p>)</p>
<p>annotations.append(annotation)</code></pre></p>
<strong>Features:</strong>
<ul>
<li>Interactive date range selection</li>
<li>Temperature and humidity on same graph</li>
<li>Visual markers for device restarts and control actions</li>
<li>Gap detection when devices go offline</li>
</ul>
<p>---</p>
<h2>Configuration Architecture</h2>
<p>YAML-based configuration with environment secrets:</p>
<pre><code><h1>config.yaml</h1>
<p>server:</p>
<p>allowed_hosts: ["10.0.1.18", "127.0.0.1"]</p>
<p>port: 8181</p>
<p>debug_level: DEBUG</p>
<p>homebridge:</p>
<p>server_ip: 10.0.1.18</p>
<p>server_port: 8581</p>
<p>mode: DEBUG</p>
<p>DEBUG:</p>
<p>accessory_refresh_interval: 120</p>
<p>PROD:</p>
<p>accessory_refresh_interval: 28800</p>
<h1>secrets.env (not committed)</h1>
<p>DJANGO_SECRET_KEY=...</p>
<p>HOMEBRIDGE_UI_PASSWORD=...</p>
<p>HOMEASSISTANT_LONG_LIVED_TOKEN=...</code></pre></p>
<p>---</p>
<h2>Device Protocol</h2>
<p>Devices communicate via simple HTTP endpoints:</p>
<h3>Device Reports Sensor Data</h3>
<pre><code>POST /homebridgecomm/reading/bedroom_sensor
<p>Content-Type: application/json</p>
<p>{</p>
<p>"temp": 72.5,</p>
<p>"rh": 65.3</p>
<p>}</code></pre></p>
<h3>Server Responds with Action</h3>
<pre><code>HTTP/1.1 200 OK
<p>Turn heater ON</code></pre></p>
<p>or</p>
<pre><code>HTTP/1.1 200 OK
<p>no action</code></pre></p>
<h3>Device Requests Configuration</h3>
<pre><code>GET /homebridgecomm/config/bedroom_sensor</code></pre>
<strong>Response:</strong>
<pre><code>{
<p>"heater_switch_name": "bedroom_heater",</p>
<p>"heater_temp_threshold": 75,</p>
<p>"temp_threshold_gap": 2,</p>
<p>"humidifier_switch_name": "bedroom_humidifier",</p>
<p>"rh_threshold": 60,</p>
<p>"rh_threshold_gap": 5</p>
<p>}</code></pre></p>
<p>---</p>
<h2>Interesting Implementation Patterns</h2>
<h3>1. Singleton Pattern for External Service Connections</h3>
<pre><code>class HomeBridgeServer:
<p>_instance = None</p>
<p>_initialized = False</p>
<p>def __new__(cls):</p>
<p>if cls._instance is None:</p>
<p>cls._instance = super().__new__(cls)</p>
<p>return cls._instance</code></pre></p>
<p>Ensures only one connection per external service, with shared authentication state.</p>
<h3>2. Aggressive Caching</h3>
<pre><code>def cached_obj(obj_name, obj_type, cache_duration=300, **kwargs):
<p>obj = cache.get(obj_name)</p>
<p>if obj is None:</p>
<p>obj = obj_type.objects.get(**kwargs)</p>
<p>cache.set(obj_name, obj, cache_duration)</p>
<p>return obj</code></pre></p>
<p>Device configurations are cached for 5 minutes to reduce database load on frequent sensor updates.</p>
<h3>3. Feature Flags on Devices</h3>
<pre><code>device.features = {
<p>"temp_switch_control": True,</p>
<p>"humidifier_switch_control": True,</p>
<p>"hass_sensors": True</p>
<p>}</code></pre></p>
<p>Flexible per-device capability discovery.</p>
<h3>4. Validation with Sanity Checks</h3>
<pre><code>if not 0 < data['temp'] < 150 or not 0 <= data['rh'] <= 100:
<p>return bad_request(request, Exception("data values not in range"))</p>
<p>if v <= 32:  # Fahrenheit freezing point</p>
<p>logger.info(f"{name} sent invalid data: {data}")</p>
<p>break</code></pre></p>
<p>Protects against sensor failures and bad data.</p>
<p>---</p>
<h2>Technology Choices</h2>
<p>| Component | Technology | Why? |</p>
<p>|-----------|-----------|------|</p>
<p>| <strong>Web Framework</strong> | Django 5.0 | Mature ORM, admin interface, built-in auth |</p>
<p>| <strong>API</strong> | Django REST Framework | Clean API views, serialization |</p>
<p>| <strong>Database</strong> | SQLite | Simple deployment, sufficient for home use |</p>
<p>| <strong>Visualization</strong> | Plotly | Interactive graphs, easy Django integration |</p>
<p>| <strong>Static Files</strong> | WhiteNoise | Serve static files without separate nginx |</p>
<p>| <strong>Task Scheduling</strong> | django-cron | Periodic tasks (e.g., Homebridge restart) |</p>
<p>| <strong>WebSocket</strong> | websocket-client | Home Assistant real-time connection |</p>
<p>| <strong>Config</strong> | PyYAML + python-dotenv | Separate config from secrets |</p>
<p>---</p>
<h2>Real-World Application</h2>
<p>This isn't a toy project—it's a production system managing:</p>
<ul>
<li><strong>Multiple temp/humidity sensors</strong> in different rooms</li>
<li><strong>Smart switches and heaters</strong> via Homebridge</li>
<li><strong>Mushroom growing chambers</strong> with specialized control</li>
<li><strong>Firmware updates</strong> for custom Arduino devices</li>
<li><strong>Historical data</strong> for trend analysis</li>
</ul>
<p>The system runs continuously on a local server, with devices checking in every ~2 minutes. The delta compression means months of data fit in a lightweight SQLite database, and the visualization tools provide immediate insight into environmental trends.</p>
<p>---</p>
<h2>Code Quality & Patterns</h2>
<strong>Strengths:</strong>
<ul>
<li>Clean separation of concerns (models, control logic, views)</li>
<li>Comprehensive logging throughout</li>
<li>Graceful error handling with fallbacks</li>
<li>Singleton pattern for expensive resources</li>
<li>Caching strategy to reduce load</li>
<li>Delta compression for efficient storage</li>
</ul>
<strong>Areas for Enhancement:</strong>
<ul>
<li>Could benefit from async/await for external API calls</li>
<li>More comprehensive unit tests</li>
<li>Configuration could use environment-based overrides</li>
<li>WebSocket reconnection logic could be more robust</li>
</ul>
<p>---</p>
<h2>Conclusion</h2>
<p>SmarterHome Webserver is a great example of practical systems integration. It bridges the gap between custom hardware, commercial home automation platforms, and specialized applications (like mushroom cultivation).</p>
<p>The most impressive aspects:</p>
<p>1. <strong>Delta compression</strong> for sensor data—elegant and effective</p>
<p>2. <strong>Multi-platform integration</strong> (Homebridge HTTP + Home Assistant WebSocket)</p>
<p>3. <strong>Hysteresis-based control</strong> to prevent rapid toggling</p>
<p>4. <strong>OTA firmware updates</strong> for custom devices</p>
<p>5. <strong>Specialized mushroom automation</strong> with FAE scheduling</p>
<p>This project demonstrates how to build a robust IoT orchestration layer that extends commercial platforms with custom logic and hardware—all with a relatively lightweight Django application.</p>
<p>---</p>
<strong>View the source:</strong> <a href="https://github.com/rmfalco89/smarterHome-webserver" target="_blank">github.com/rmfalco89/smarterHome-webserver</a>
        </article>
        
        <footer>
            <div class="social-links">
                <a href="https://www.linkedin.com/in/rimarino/" target="_blank" title="LinkedIn">
                    <svg xmlns="http://www.w3.org/2000/svg" role="img" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" width="20" height="20"><path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect x="2" y="9" width="4" height="12"></rect><circle cx="4" cy="4" r="2"></circle></svg>
                </a>
                <a href="mailto:rmfalco.89@gmail.com" title="Email">
                    <svg xmlns="http://www.w3.org/2000/svg" role="img" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" width="20" height="20"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline></svg>
                </a>
            </div>
            <p>Built by Riccardo Marino</p>
        </footer>
    </div>
</body>
</html>